<html class="" lang="ru"><head><meta charset="utf-8"/><meta content="width=device-width,initial-scale=1" name="viewport"/><title>JavaScript. Профессиональная разработка веб-интерфейсов #25 / HTML Academy</title><script async="" crossorigin="anonymous" integrity="sha384-d/yhnowERvm+7eCU79T/bYjOiMmq4F11ElWYLmt0ktvYEVgqLDazh4+gW9CKMpYW" src="https://cdn.amplitude.com/libs/amplitude-5.2.2-min.gz.js" type="text/javascript"></script><script async="" src="https://www.google-analytics.com/plugins/ua/linkid.js" type="text/javascript"></script><script async="" src="https://mc.yandex.ru/metrika/tag.js"></script><script async="" src="https://www.google-analytics.com/analytics.js" type="text/javascript"></script><script async="" src="https://www.googletagmanager.com/gtm.js?id=GTM-W3ZS73J"></script><script>document.documentElement.classList.remove('no-js');</script><script data-project="10" data-sample-rate="0.25" data-sentry="a64ad1fd170847efa544b305c67696aa" data-version="2" src="https://assets.htmlacademy.ru/js/sentry.js"></script><link href="/static/css/octicons-3.3.0.min.css" rel="stylesheet"/><link href="https://assets.htmlacademy.ru/css/core.v197.css" rel="stylesheet"/><link href="https://assets.htmlacademy.ru/css/text.v77.css" rel="stylesheet"/><link href="https://assets.htmlacademy.ru/css/extended-ui-kit.v66.css" rel="stylesheet"/><link href="https://assets.htmlacademy.ru/css/up.v188.css" rel="stylesheet"/><link href="https://assets.htmlacademy.ru/css/blog.v137.css" rel="stylesheet"/><meta content="#2d2d44" name="theme-color"/><link color="#18213F" href="/meta/favicon.svg" rel="mask-icon"/><meta content="JavaScript. Профессиональная разработка веб-интерфейсов #25" name="application-name"/><meta content="JavaScript. Профессиональная разработка веб-интерфейсов #25" name="apple-mobile-web-app-title"/><link href="/meta/javascript-touch-icon.png" rel="apple-touch-icon"/><link href="/meta/javascript-favicon.ico" rel="shortcut icon" type="image/x-icon"/><link href="/meta/javascript.webmanifest" rel="manifest"/><link as="font" crossorigin="anonymous" href="https://assets.htmlacademy.ru/fonts/tt-norms-pro-400-normal.v2.woff2" rel="preload" type="font/woff2"/><link as="font" crossorigin="anonymous" href="https://assets.htmlacademy.ru/fonts/tt-norms-pro-500-normal.v2.woff2" rel="preload" type="font/woff2"/><link as="font" crossorigin="anonymous" href="https://assets.htmlacademy.ru/fonts/tt-norms-pro-700-normal.v2.woff2" rel="preload" type="font/woff2"/><link as="font" crossorigin="anonymous" href="https://assets.htmlacademy.ru/fonts/ubuntu-mono.woff2?cs=7882c41280d8256972fd2b8ee74e2d7d28a857b6" rel="preload" type="font/woff2"/><link as="script" href="https://assets.htmlacademy.ru/js/general.v223.js" rel="preload"/><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-W3ZS73J');</script><script charset="utf-8" src="https://assets.htmlacademy.ru/js/b30983.js"></script><script charset="utf-8" src="https://assets.htmlacademy.ru/js/b42759.js"></script><script charset="utf-8" src="https://assets.htmlacademy.ru/js/c35c41.js"></script><script charset="utf-8" src="https://assets.htmlacademy.ru/js/21aceb.js"></script><script charset="utf-8" src="https://assets.htmlacademy.ru/js/7ea5a2.js"></script><script charset="utf-8" src="https://assets.htmlacademy.ru/js/207ec5.js"></script><script charset="utf-8" src="https://assets.htmlacademy.ru/js/17be68.js"></script><script charset="utf-8" src="https://assets.htmlacademy.ru/js/a0cc69.js"></script><script charset="utf-8" src="https://assets.htmlacademy.ru/js/5dcf46.js"></script><script charset="utf-8" src="https://assets.htmlacademy.ru/js/69be84.js"></script><script charset="utf-8" src="https://assets.htmlacademy.ru/js/24dc6b.js"></script><style>.hljs {display: block;color: black;}.hljs-keyword,.hljs-builtin-name,.hljs-selector-id {color: blue;}.hljs-subst,.hljs-attr {color: black;}.hljs-title,.hljs-type {color: #0000A2;}.hljs-literal {color: rgb(88,92,246);}.hljs-number {color: rgb(0,0,205);}.hljs-regexp,.hljs-string,.bash,.hljs-doctag,.hljs-selector-pseudo,.hljs-code {color: rgb(3,106,7);}.hljs-selector-class,.hljs-variable {color: rgb(49,132,149);}.hljs-selector-tag,.hljs-selector-attr,.hljs-link {color: rgb(197,6,11);}.hljs-attribute {color: rgb(109,121,222);}.hljs-comment,.hljs-quote {color: rgb(188,20,175);}.hljs-meta {color: rgb(104,104,91);}.hljs-tag {color: rgb(0,22,142);}.hljs-addition {background-color: rgba(155, 185, 85, 0.2);}.hljs-deletion {background-color: rgba(255, 0, 0, 0.2);}.hljs-params,.hljs-built_in {color: rgb(49, 132, 149);}</style><script charset="utf-8" src="https://assets.htmlacademy.ru/js/b10dac.js"></script><script charset="utf-8" src="https://assets.htmlacademy.ru/js/8f4e02.js"></script><script charset="utf-8" src="https://assets.htmlacademy.ru/js/183270.js"></script></head><body><noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-W3ZS73J" style="display:none;visibility:hidden" width="0"></iframe></noscript><div class="page-content page-content--relative page-content--php page-content--up"><div class="blog-section blog-section--page blog-section--black-white"><div class="blog-section__wrap"><div class="side-menu__wrap"><div class="side-menu side-menu--main side-menu--php side-menu--up"><div class="side-menu__title"><a class="side-menu__link side-menu__link--main link" href="/javascript/25/book">Учебник</a><button class="side-menu__button" type="button"><span class="sr-only">Развернуть / Свернуть</span><svg aria-hidden="true" height="16" width="8"><use xlink:href="/img/sprites/up.v9.svg#icon-arrow-right"></use></svg></button></div><ul class="side-menu__list"><li class="side-menu__item"><button class="side-menu__toggle" type="button"><span class="sr-only">Развернуть / Свернуть</span></button><a class="link" href="/javascript/25/book/1">1. Введение в JavaScript</a><ul class="side-menu__inner-list"><li class="side-menu__inner-item"><a href="/javascript/25/book/1.1">1.1. Что такое JavaScript</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/1.2">1.2. Спецификация</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/1.3">1.3. Синтаксис</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/1.4">1.4. Подключение JavaScript к странице</a><ul class="side-menu__inner-list side-menu__inner-list--second"><li class="side-menu__inner-item"><a href="/javascript/25/book/1.4.1">1.4.1. Атрибуты defer и async</a></li></ul></li></ul></li><li class="side-menu__item"><button class="side-menu__toggle" type="button"><span class="sr-only">Развернуть / Свернуть</span></button><a class="link" href="/javascript/25/book/2">2. Основы JavaScript</a><ul class="side-menu__inner-list"><li class="side-menu__inner-item"><a href="/javascript/25/book/2.1">2.1. Переменные</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/2.2">2.2. Именование переменных и функций</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/2.3">2.3. Типы данных в JavaScript</a><ul class="side-menu__inner-list side-menu__inner-list--second"><li class="side-menu__inner-item"><a href="/javascript/25/book/2.3.1">2.3.1. Примитивы</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/2.3.2">2.3.2. Объектные типы данных</a></li></ul></li><li class="side-menu__inner-item"><a href="/javascript/25/book/2.4">2.4. Сравнение сложных типов данных</a><ul class="side-menu__inner-list side-menu__inner-list--second"><li class="side-menu__inner-item"><a href="/javascript/25/book/2.4.1">2.4.1. Динамическое приведение типов</a></li></ul></li><li class="side-menu__inner-item"><a href="/javascript/25/book/2.5">2.5. Комментарии в коде</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/2.6">2.6. Точка с запятой</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/2.7">2.7. Функции</a><ul class="side-menu__inner-list side-menu__inner-list--second"><li class="side-menu__inner-item"><a href="/javascript/25/book/2.7.1">2.7.1. rest-параметры функций</a></li></ul></li><li class="side-menu__inner-item"><a href="/javascript/25/book/2.8">2.8. Стрелочные функции</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/2.9">2.9. Оператор switch</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/2.10">2.10. Тернарный оператор</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/2.11">2.11. Строгий режим</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/2.12">2.12. Контекст функций и проблема потери окружения</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/2.13">2.13. Функции-конструкторы</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/2.14">2.14. Введение в прототипы</a></li></ul></li><li class="side-menu__item"><button class="side-menu__toggle" type="button"><span class="sr-only">Развернуть / Свернуть</span></button><a class="link" href="/javascript/25/book/3">3. Массивы и объекты</a><ul class="side-menu__inner-list"><li class="side-menu__inner-item"><a href="/javascript/25/book/3.1">3.1. Массивы и их методы</a><ul class="side-menu__inner-list side-menu__inner-list--second"><li class="side-menu__inner-item"><a href="/javascript/25/book/3.1.1">3.1.1. Склейка элементов массива</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/3.1.2">3.1.2. Объединение массивов в один новый</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/3.1.3">3.1.3. Копирование массива или его части</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/3.1.4">3.1.4. Расположение элементов массива в обратном порядке</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/3.1.5">3.1.5. Поиск элементов в массиве</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/3.1.6">3.1.6. Перебор массива</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/3.1.7">3.1.7. Преобразование массива</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/3.1.8">3.1.8. Свёртка массива</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/3.1.9">3.1.9. Проверка каждого элемента массива на условие «удовлетворяют все»</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/3.1.10">3.1.10. Проверка каждого элемента массива на условие «удовлетворяет хоть один»</a></li></ul></li><li class="side-menu__inner-item"><a href="/javascript/25/book/3.2">3.2. spread-синтаксис</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/3.3">3.3. Отличия spread-синтаксиса от rest-параметров</a></li></ul></li><li class="side-menu__item"><button class="side-menu__toggle" type="button"><span class="sr-only">Развернуть / Свернуть</span></button><a class="link" href="/javascript/25/book/4">4. DOM</a><ul class="side-menu__inner-list"><li class="side-menu__inner-item"><a href="/javascript/25/book/4.1">4.1. Что такое DOM</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/4.2">4.2. DOM-дерево</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/4.3">4.3. Поиск в деревьях</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/4.4">4.4. Живые и неживые коллекции в JavaScript</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/4.5">4.5. DOM и разметка</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/4.6">4.6. Шаблоны и данные</a></li></ul></li><li class="side-menu__item"><button class="side-menu__toggle" type="button"><span class="sr-only">Развернуть / Свернуть</span></button><a class="link" href="/javascript/25/book/5">5. Асинхронность и события</a><ul class="side-menu__inner-list"><li class="side-menu__inner-item"><a href="/javascript/25/book/5.1">5.1. Синхронные и асинхронные операции</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/5.2">5.2. Функции обратного вызова (колбэки)</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/5.3">5.3. Функции обратного вызова на практике</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/5.4">5.4. Действия браузера по умолчанию</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/5.5">5.5. Фазы событий</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/5.6">5.6. Делегирование событий</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/5.7">5.7. Пропуск кадров и устранение дребезга</a></li></ul></li><li class="side-menu__item"><button class="side-menu__toggle" type="button"><span class="sr-only">Развернуть / Свернуть</span></button><a class="link" href="/javascript/25/book/6">6. Модули</a><ul class="side-menu__inner-list"><li class="side-menu__inner-item"><a href="/javascript/25/book/6.1">6.1. Области видимости переменных и функций</a><ul class="side-menu__inner-list side-menu__inner-list--second"><li class="side-menu__inner-item"><a href="/javascript/25/book/6.1.1">6.1.1. Глобальная и блочная области видимости</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/6.1.2">6.1.2. Модульная область видимости, лексическое окружение и прочие нюансы</a></li></ul></li><li class="side-menu__inner-item"><a href="/javascript/25/book/6.2">6.2. Введение в ECMAScript-модули</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/6.3">6.3. Экспорт и импорт</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/6.4">6.4. Экспорт и импорт, продвинутые техники</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/6.5">6.5. Пути импорта</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/6.6">6.6. Понятие API</a></li></ul></li><li class="side-menu__item side-menu__item--active"><button class="side-menu__toggle" type="button"><span class="sr-only">Развернуть / Свернуть</span></button><a class="link" href="/javascript/25/book/7">7. Работа с сетью</a><ul class="side-menu__inner-list"><li class="side-menu__inner-item"><a href="/javascript/25/book/7.1">7.1. Промисы</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/7.2">7.2. Цепочки промисов</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/7.3">7.3. Методы глобального объекта Promise</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/7.4">7.4. Async/Await</a></li><li class="side-menu__inner-item side-menu__inner-item--current"><a href="/javascript/25/book/7.5">7.5. Протокол HTTP</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/7.6">7.6. Практика выполнения HTTP-запросов</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/7.7">7.7. JSON</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/7.8">7.8. Fetch API</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/7.9">7.9. Безопасность. XSS (Cross-site-scripting)</a></li></ul></li><li class="side-menu__item"><button class="side-menu__toggle" type="button"><span class="sr-only">Развернуть / Свернуть</span></button><a class="link" href="/javascript/25/book/8">8. DevTools (инструменты разработчика в браузере)</a><ul class="side-menu__inner-list"><li class="side-menu__inner-item"><a href="/javascript/25/book/8.1">8.1. Знакомство с DevTools</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/8.2">8.2. Вкладка Console</a><ul class="side-menu__inner-list side-menu__inner-list--second"><li class="side-menu__inner-item"><a href="/javascript/25/book/8.2.1">8.2.1. Как сообщения попадают в консоль</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/8.2.2">8.2.2. Консоль удобна для проверки гипотез</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/8.2.3">8.2.3. Почему опасно выполнять незнакомый код в консоли</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/8.2.4">8.2.4. Опция «Preserve log»</a></li></ul></li><li class="side-menu__inner-item"><a href="/javascript/25/book/8.3">8.3. Вкладка Elements</a><ul class="side-menu__inner-list side-menu__inner-list--second"><li class="side-menu__inner-item"><a href="/javascript/25/book/8.3.1">8.3.1. Обзор вкладки Elements</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/8.3.2">8.3.2. Как посмотреть обработчики на элементе</a></li></ul></li><li class="side-menu__inner-item"><a href="/javascript/25/book/8.4">8.4. Вкладка Sources</a><ul class="side-menu__inner-list side-menu__inner-list--second"><li class="side-menu__inner-item"><a href="/javascript/25/book/8.4.1">8.4.1. Обзор панелей вкладки Sources</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/8.4.2">8.4.2. Точки останова</a></li></ul></li><li class="side-menu__inner-item"><a href="/javascript/25/book/8.5">8.5. Вкладка Network</a><ul class="side-menu__inner-list side-menu__inner-list--second"><li class="side-menu__inner-item"><a href="/javascript/25/book/8.5.1">8.5.1. Обзор вкладки Network</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/8.5.2">8.5.2. Опции Preserve log и Disable cache</a></li></ul></li></ul></li><li class="side-menu__item"><button class="side-menu__toggle" type="button"><span class="sr-only">Развернуть / Свернуть</span></button><a class="link" href="/javascript/25/book/9">9. Рабочие инструменты</a><ul class="side-menu__inner-list"><li class="side-menu__inner-item"><a href="/javascript/25/book/9.1">9.1. Node.js и npm</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/9.2">9.2. Линтер ESLint</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/9.3">9.3. Локальный сервер Browsersync</a></li></ul></li><li class="side-menu__item"><button class="side-menu__toggle" type="button"><span class="sr-only">Развернуть / Свернуть</span></button><a class="link" href="/javascript/25/book/10">10. Git и GitHub</a><ul class="side-menu__inner-list"><li class="side-menu__inner-item"><a href="/javascript/25/book/10.1">10.1. Система контроля версий Git</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/10.2">10.2. GitHub</a><ul class="side-menu__inner-list side-menu__inner-list--second"><li class="side-menu__inner-item"><a href="/javascript/25/book/10.2.1">10.2.1. Регистрация на GitHub</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/10.2.2">10.2.2. Работа с репозиториями</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/10.2.3">10.2.3. Code review</a></li></ul></li><li class="side-menu__inner-item"><a href="/javascript/25/book/10.3">10.3. Терминал</a><ul class="side-menu__inner-list side-menu__inner-list--second"><li class="side-menu__inner-item"><a href="/javascript/25/book/10.3.1">10.3.1. Начало работы с Git в терминале</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/10.3.2">10.3.2. Установка SSH-ключей</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/10.3.3">10.3.3. Клонирование репозитория</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/10.3.4">10.3.4. Работа с ветками</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/10.3.5">10.3.5. Запись изменений в репозиторий</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/10.3.6">10.3.6. Синхронизация репозиториев</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/10.3.7">10.3.7. Конфликты</a></li><li class="side-menu__inner-item"><a href="/javascript/25/book/10.3.8">10.3.8. Операции отмены</a></li></ul></li></ul></li></ul></div></div><div class="blog-section__content"><div class="blog-section__wrap-inner"><div class="post-info post-info--up"><p class="post-info__head"><span class="post-info__type">Теория</span><span class="post-info__timer">~ 17 минут</span></p><h2 class="post-info__title">Глава 7.5. Протокол HTTP</h2></div><div class="post-content"><p>HTTP — это сетевой протокол прикладного уровня, то есть для «общения» между программами. Протокол появился в начале 90-х и применяется до сих пор. Аббревиатура HTTP расшифровывается как «HyperText Transfer Protocol» (протокол передачи гипертекста).</p><p>У этого протокола есть несколько версий. На сегодняшний день актуальными являются <a href="https://tools.ietf.org/html/rfc2616">версия 1.1</a> и <a href="https://tools.ietf.org/html/rfc7540">2.0</a>. Окончательная спецификация второй версии появилась в 2015 году. Сейчас идут работы над <a href="https://ru.wikipedia.org/wiki/HTTP/3">третьей версией</a>.</p><p>Вся информация о любых протоколах представлена в документах RFC (Request for Comments). Протокол HTTP не является исключением. Полные сведения о первой версии протокола детально описаны в <a href="https://tools.ietf.org/html/rfc2616">RFC2616</a>.</p><p>Изначально протокол HTTP проектировался для передачи гипертекста (вспомните расшифровку аббревиатуры). Однако, сегодня он используется и в качестве транспорта для передачи информации другими протоколами прикладного уровня. Такие протоколы как XML-RPC, WebDav, WS могут использовать HTTP в качестве транспорта.</p><p></p><figure><img alt="Рисунок 1. Транспортные и прикладные протоколы" src="C:/Users/ivy-m/PycharmProjects/scrapper/scrapper2/results//assets/intensives/javascript/25/book/07-network/05-http/protocols.png" title="Рисунок 1. Транспортные и прикладные протоколы"/><figcaption>Рисунок 1. Транспортные и прикладные протоколы</figcaption></figure><p></p><h2 id="printsip-raboti">Принцип работы</h2><p>С HTTP-протоколом мы сталкиваемся постоянно — на нём держится всемирная паутина. Всякий раз при переходе на любой веб-сайт применяется именно HTTP-протокол. Браузер использует его для взаимодействия с сервером.</p><p>Возможно, вы этого не замечали: название протокола вводится вместе с адресом сайта. Современные браузеры не требуют исполнения этого правила. Более того, по умолчанию они скрывают применяемый протокол. Обратите внимание на адресную строку. В ней отображается адрес ресурса без указания протокола. Однако, если кликнуть в адресную строку, то адрес отобразится полностью, включая протокол.</p><p></p><figure><img alt="Рисунок 2. Протокол в адресной строке" src="C:/Users/ivy-m/PycharmProjects/scrapper/scrapper2/results//assets/intensives/javascript/25/book/07-network/05-http/http-in-address-string.png" title="Рисунок 2. Протокол в адресной строке"/><figcaption>Рисунок 2. Протокол в адресной строке</figcaption></figure><p></p><p>На втором рисунке видно, что используется протокол <code>HTTPS</code>. Немного позже мы расскажем, чем он отличается от <code>HTTP</code>.</p><p>Напомним: HTTP-протокол решает задачу обмена данными. Участники обмена: сервер и клиент. Клиент (например, браузер) формирует запрос и отправляет его серверу. Сервер (программа веб-сервер) получает запрос, анализирует и возвращает ответ. Клиент, получив ответ, обрабатывает его и выполняет какое-то действие. Например, отрисовывает страницу.</p><p></p><figure><img alt="Рисунок 3. HTTP в действии" src="C:/Users/ivy-m/PycharmProjects/scrapper/scrapper2/results//assets/intensives/javascript/25/book/07-network/05-http/http-in-action.png" title="Рисунок 3. HTTP в действии"/><figcaption>Рисунок 3. HTTP в действии</figcaption></figure><p></p><p>Общий принцип должен быть понятен, но как именно браузер соединяется с сервером? Ведь на сервере могут быть запущены сотни приложений, которые принимают соединения. Как браузер находит именно веб-сервер?</p><p>Когда вы вводите адрес сайта в адресной строке и нажимаете <code>Enter</code>, происходит примерно следующее (рассматриваем максимально упрощённый сценарий).</p><p>Чтобы соединиться с сервером, браузеру необходимо получить его IP-адрес. Мы привыкли пользоваться символьными адресами — их проще запомнить, чем сочетание цифр. Программы, наоборот, предпочитают числа. После ввода в адресной строке <code>htmlacademy.ru</code>, первой задачей браузера станет получение IP-адреса для <code>htmlacademy.ru</code>. Для этого он выполнит запрос к DNS-серверу, который на основании символьного адреса вернёт IP-адрес — <code>178.79.181.169</code>.</p><blockquote><p>DNS-сервер — это сервер, на котором запущено приложение для обработки DNS-запросов. На основании символьного адреса (например, <code>htmlacademy.ru</code>), DNS-сервер возвращает IP-адрес сервера.</p></blockquote><p>Получив IP-адрес, браузер попытается установить соединение с сервером. Для этого он воспользуется протоколом транспортного уровня — <a href="https://ru.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a>. На сервере может быть запущено множество сервисов, но браузер по умолчанию подключится к 80-му порту. Почему именно к нему — расскажем позже.</p><p>Установив соединение, браузер сформирует HTTP-запрос и передаст его серверу. Здесь и вступает в работу протокол HTTP. Две программы, браузер и сервер, начинают «общаться». Браузер направляет запрос, а сервер — ответ. Запрос — это обычный текст, составленный в соответствии с правилами протокола. Запрос включает в себя служебную информацию и, самое главное, адрес ресурса, который требуется получить.</p><p>Вернёмся к номеру порта. А почему браузер пытается установить соединение именно на 80-й порт? Как он определяет, что его ждут именно там? По умолчанию веб-серверы ожидают подключений именно на 80-м порту. Это договорённость.</p><p>Это, конечно, не означает, что веб-сервер может работать только на 80-м порту. Администратор сервера может изменить правила игры и настроить веб-сервер для приёма соединений от клиентов на другой порт. Например, <code>3666</code>.</p><p>В этом случае порт необходимо указать самостоятельно при вводе адреса. Порт указывается после символа двоеточие (<code>:</code>). Например, если сервер <code>htmlacademy.ru</code> принимает соединения на порт <code>3666</code>, то адрес станет таким: <code>https://htmlacademy.ru:3666</code>.</p><h2 id="http-zapros">HTTP-запрос</h2><p>HTTP-запрос состоит из нескольких частей: строка запроса, заголовки (служебная информация) и тело запроса (body). Обязательной является первая часть. Заголовки и тело запроса могут отсутствовать.</p><p></p><figure><img alt="Рисунок 4. Структура HTTP-запроса" src="C:/Users/ivy-m/PycharmProjects/scrapper/scrapper2/results//assets/intensives/javascript/25/book/07-network/05-http/http-method.png" title="Рисунок 4. Структура HTTP-запроса"/><figcaption>Рисунок 4. Структура HTTP-запроса</figcaption></figure><p></p><h3 id="stroka-zaprosa">Строка запроса</h3><p>Строка запроса начинается с определения <em>HTTP-метода</em>. Метод позволяет понять серверу, как следует обрабатывать запрос. Методы определены в <a href="https://tools.ietf.org/html/rfc7231#section-4">спецификации</a>. Их немало, но заучивать все прямо сейчас не нужно. Мы постепенно разберёмся с основными на практике.</p><p>После HTTP-метода указывается адрес ресурса (путь, куда отправляем запрос) и версия HTTP-протокола. С адресом ресурса всё относительно понятно: <code>/</code> (корень сайта), <code>/about.html</code> (страница <code>about.html</code>) и так далее.</p><p>С версией протокола не всё так очевидно. Их несколько. Сегодня чаще всего применяются версия <code>1.1</code> и <code>2.0</code>. Первая версия (<code>1.0</code>) тоже используется, но реже. Между версиями есть существенные различия. В новых версиях реализованы дополнительные возможности. О наиболее важных различиях расскажем в отдельном разделе. Пример строки запроса:</p><pre><code class="hljs http"><span class="hljs-keyword">HEAD</span> <span class="hljs-string">/posts</span> <span class="hljs-meta">HTTP/1.1</span>
</code></pre><h2 id="zagolovki-(headers)">Заголовки (Headers)</h2><p>После строки запроса можно указать дополнительную информацию, которая может пригодиться серверу для обработки запроса. Обратите внимание на слово «может». Заголовков может и не быть (при использовании первой версии протокола), но на практике такое бывает редко. Каждый заголовок строго описывается на отдельной строке в формате <code>ключ:значение</code>:</p><pre><code class="hljs http"><span class="hljs-keyword">HEAD</span> <span class="hljs-string">/post</span> <span class="hljs-meta">HTTP/1.1</span>
<span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Google Chrome
</code></pre><p>В примере мы указали заголовок «User-Agent». Это информационный заголовок, который обычно содержит название браузера или программы (например, название браузера), которая сформировала запрос. Регистр заголовков не важен. В литературе нередко используют верхний регистр. Но это необязательное правило. Ничего не мешает пользоваться строчными буквами или придерживаться CamelCase. Последний особенно удобен в плане читабельности.</p><p>Спецификация протокола определяет множество заголовков (<code>Content-Type</code>, <code>Content-Length</code>, <code>Host</code> и другие), но есть возможность описывать собственные заголовки. Это может потребоваться для передачи бэкенду дополнительной информации, специфичной для определённого приложения. Такие заголовки принято называть с буквы «X-». Например:</p><pre><code class="hljs http"><span class="hljs-keyword">HEAD</span> <span class="hljs-string">/post</span> <span class="hljs-meta">HTTP/1.1</span>
<span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Google Chrome
<span class="hljs-attribute">X-Token</span><span class="hljs-punctuation">: </span>secret token
</code></pre><p>В примере приведён собственный заголовок <code>X-Token</code> со значением <code>secret token</code>. Вы можете описать сколько угодно таких заголовков.</p><h3 id="zagolovok-host">Заголовок Host</h3><p>Вернёмся к стандартным заголовкам и обсудим наиболее важный из них — <code>Host</code>. Он появился в версии протокола <code>1.1</code> и является обязательным. Поэтому, если в тексте запроса вы указали версию протокола HTTP от <code>1.1</code> и выше, то важно не забыть указать заголовок <code>Host</code>.</p><p>Почему этот заголовок так важен? Дело в том, что на одном сервере может размещаться множество веб-сайтов. Сервер один, у него один IP-адрес, а сайтов много, и все на разных доменах. Ситуация типичная. В самом начале этого материала мы говорили, что перед тем, как отправить запрос, браузер определяет IP-адрес сервера, устанавливает соединение. Вопрос, если на одном сервере размещается несколько разных веб-сайтов (с разными доменами), то как сервер поймёт, для какого именно веб-сайта предназначен запрос?</p><p>В этом ему поможет значение, указанное в заголовке <code>Host</code>. Когда разрабатывалась первая версия протокола, то никто не думал, что веб-сайтов может стать настолько много. Предполагалось, что на одном сервере может размещаться только один веб-сайт. На практике всё случилось по-другому: сайтов много, а количество IP-адресов ограничено. Это привело к необходимости обновления протокола.</p><p>Одной из новинок версии <code>1.1</code> стала поддержка виртуальных хостов. На одном сервере может быть произвольное количество разных веб-сайтов. Чтобы веб-сервер понимал, кому предназначен запрос, применяется заголовок <code>Host</code>. Рассмотрим пример:</p><pre><code class="hljs http"><span class="hljs-keyword">HEAD</span> <span class="hljs-string">/posts</span> <span class="hljs-meta">HTTP/1.1</span>
<span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>jsonplaceholder.typicode.com
</code></pre><p>Значением заголовка <code>Host</code> является адрес хоста <code>jsonplaceholder.typicode.com</code>. Неважно сколько веб-сайтов располагается на сервере, запрос будет передан именно <code>jsonplaceholder.typicode.com</code>.</p><p>А что же будет, если не указать заголовок <code>Host</code>? Всё сломается? Нет, ни в коем случае. Практически любой веб-сервер настроен так, что у него есть хост, который используется по умолчанию. Если вы не укажете <code>Host</code>, то запрос будет выполнен для веб-сайта, который прописан в настройках по умолчанию.</p><h2 id="telo-zaprosa-(body)">Тело запроса (Body)</h2><p>После заголовков описывается тело запроса. Тело запроса необязательно. В одних запросах оно может быть, а в других нет. Зачем же нужно тело запроса? Если заголовки позволяют передать различную служебную информацию (попросту уточняют запрос), то в теле запроса передаются полезные данные.</p><p>Простой пример. Всем вам приходилось сталкиваться с различными формами на веб-страницах. Оформление заказа в интернет-магазине, форма входа в закрытую часть сайта и так далее. Формы применяются везде. Так вот, при отправке формы на сервере формируется соответствующий HTTP-запрос. Введённые в форму данные будут подставлены в специальном формате в тело запроса. Рассмотрим на примере:</p><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/posts</span> <span class="hljs-meta">HTTP/1.1</span>
<span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>jsonplaceholder.typicode.com
<span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json
<span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>88

<span class="json">{
    <span class="hljs-attr">"title"</span>: <span class="hljs-string">"Новая публикация"</span>,
    <span class="hljs-attr">"body"</span>: <span class="hljs-string">"Текст публикации"</span>,
    <span class="hljs-attr">"userId"</span>: <span class="hljs-number">31337</span>
}
</span></code></pre><p>Мы привели пример запроса <code>POST</code> к ресурсу <code>/posts</code> сервиса <code>jsonplaceholder.typicode.com</code>. На этот ресурс сервер ожидает получить данные в формате JSON, поэтому дополнительно указываем стандартный заголовок <code>Content-Type</code>. В нём определяем тип содержимого (<code>application/json</code>). Более подробно о заголовке и типах содержимого вы можете прочитать в спецификации.</p><p>После указания типа контента, мы используем ещё один стандартный заголовок <code>Content-Length</code>. Этот заголовок сообщит серверу о размере тела запроса. Значение указывается в байтах. В нашем случае, тело запроса занимает <code>88</code> символов. Сервер будет ожидать получения именно такого количества байтов, как и указано в этом заголовке.</p><p>Перечисленные заголовки важны для сервера, чтобы он правильно обработал запрос. Представьте себя на месте сервера. Как понять, что данные пришли именно в JSON-формате? Можно попробовать их распарсить и определить тип алгоритмическим путём, но проще, если клиент сам сообщит тип данных и их размер. Заголовки <code>Content-Type</code> и <code>Content-Length</code> были созданы именно для этого.</p><p>Хорошо, если с типом контента всё более менее понятно, то в чём смысл <code>Content-Length</code>? Почему сервер не может дождаться пока клиент перешлёт полностью тело запроса? Ответ кроется в вопросе. А как понять, когда запрос передан полностью? Не забываем, HTTP — текстовый протокол. Соответственно используются максимально простые правила.</p><p>Об одном таком правиле уже говорили: каждый заголовок описывается на отдельной строке. Таким образом, сервер может отделить один заголовок от другого с помощью символа перевода строки.</p><p>Есть и другое правило. Для завершения запроса в текст достаточно добавить два символа перевода строки подряд. Это станет сигналом для сервера, что запрос завершён. Но как быть с телом? Ведь тело тоже может содержать символы перевода строк? Как серверу понять, что хочет клиент: завершить запрос или передать тело запроса?</p><p>Один из способов решения этой задачи заключается в применении заголовка <code>Content-Length</code>. Заголовок позволяет задать длину тела запроса, и сервер будет ждать получения ровно стольких байтов, сколько указано в заголовке <code>Content-Length</code>.</p><p>Рассмотрим пример запроса, который формируется при отправке содержимого какой-нибудь формы. Пусть такой формой станет вымышленная форма ввода логина и пароля на каком-нибудь веб-сайте. Текст HTTP-запроса может выглядеть так:</p><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/auth</span> <span class="hljs-meta">HTTP/1.1</span>
<span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded
<span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>26

<span class="ini"><span class="hljs-attr">login</span>=keks&amp;password=secret
</span></code></pre><p>Строка запроса вряд ли требует дополнительных пояснений. Уже разбирали неоднократно. За ней следуют два заголовка. Для <code>Content-Type</code> (тип контента) мы указываем значением <code>application/x-www-form-urlencoded</code>. Такой тип используется при передаче значений из форм (если форма не используется для отправки двоичных данных — файлов). Он позволит серверу понять, что отправлена форма и значения формы переданы в формате <code>ключ=значение&amp;другойКлюч=значение</code>.</p><p>В заголовке <code>Content-Length</code> указывается размер тела запроса. Длина строки тела запроса как раз равна 26 символам. Дальше идёт тело запроса. Обратите внимание на формат. Ключи отделены от значений знаком равенства и описание следующей пары начинается после символа амперсанд (<code>&amp;</code>). Получается, что этот запрос должен передать серверу значение в качестве логина (login) — <code>keks</code> и значение <code>secret</code> в качестве пароля (<code>password</code>).</p><p>Общий принцип должен быть понятен. Вопрос может возникнуть только с названиями ключей. Откуда появляется значение <code>login</code>, <code>password</code>? Они формируются на основании имён полей ввода в форме (вспомните про атрибут <code>name</code>).</p><p>Глядя на этот пример запроса, внимательные читатели могут задаться вопросом: «А что, если в значении поля встретятся символы <code>&amp;</code> или <code>=</code>. Те специальные символы, на которые ориентируется сервер при обработке запроса. Такая ситуация действительно может произойти. Эта задача решается за счёт кодирования передаваемых значений. При отправке форм браузер самостоятельно занимается кодированием. Более подробно про это вы сможете прочитать на MDN.</p><h2 id="http-otvet">HTTP-ответ</h2><p>Мы познакомились со структурой HTTP-запроса. Этих знаний достаточно для понимания работы HTTP-протокола на базовом уровне. Чуть позже мы попрактикуемся в написании и отправке запросов, а пока обсудим, что из себя представляют ответы от сервера. Ведь смысл отправки запросов заключается в получении ответов. Начнём с рассмотрения структуры ответа (смотри рисунок 5).</p><p></p><figure><img alt="Рисунок 5. Структура HTTP-ответа" src="C:/Users/ivy-m/PycharmProjects/scrapper/scrapper2/results//assets/intensives/javascript/25/book/07-network/05-http/http-response.png" title="Рисунок 5. Структура HTTP-ответа"/><figcaption>Рисунок 5. Структура HTTP-ответа</figcaption></figure><p></p><p>Начинается HTTP-ответ со строки состояния (status line). В ней указывается версия протокола (<code>HTTP/1.1</code>), код состояния (<code>200</code>) и текстовое сообщение с описанием причины выбранного кода (<code>OK</code>). На пятом рисунке представлен ответ на успешно выполненный запрос. Об этом говорит код состояния <code>200</code>. В спецификации протокола определено множество кодов состояния. Каждый такой код состоит из трёх цифр. Первая цифра определяет класс состояния, а две последующие — статус выполнения операции. Спецификация определяет 5 классов состояний:</p><ul><li>1 — информационные (informational);</li><li>2 — успешно (success);</li><li>3 — перенаправление (redirection);</li><li>4 — ошибка клиента (client error);</li><li>5 — ошибка сервера (server error).</li></ul><p>Вторая и третья цифры уточняют детали. Таким образом, все коды состояний, которые начинаются с <code>2**</code>, означают успех выполнения запроса. Чтобы их проще различать и понимать, что код означает, спецификация закрепляет за каждым текстовое название (phrase reason). Например, для кода <code>200</code> таким сообщением станет <code>OK</code>.</p><p>После строки состояния идут заголовки. Принцип описания заголовков тот же самый — <code>ключ:значение</code>. Как и клиент, сервер может передавать нестандартные заголовки. Они тоже начинаются с <code>X-</code>. Если клиент не знает о каком-то заголовке, то ничего не случится. Заголовок попросту будет проигнорирован.</p><p>Дальше идёт тело ответа. В теле содержатся полезные данные. Например, когда браузер выполняет запрос методом <code>GET</code> (для получения страницы), то в теле ответа будет HTML-код запрашиваемой страницы.</p><h2 id="http-i-https">HTTP и HTTPS</h2><p>HTTPS — это расширение протокола HTTP, а не самостоятельный протокол. Оно добавляет поддержку шифрования трафика, то есть повышает безопасность. Аббревиатура расшифровывается так: <code>HyperText Transfer Protocol Secure</code> — безопасный протокол передачи гипертекста. Соединение, установленное через HTTPS, шифруется. Таким образом, смысл в перехвате трафика теряется.</p><p>Детально рассматривать HTTPS не будем. Более подробная информация доступна в этой <a href="https://ru.wikipedia.org/wiki/HTTPS">статье</a>. Акцентируем внимание лишь на порт.</p><p>Вы знаете: по умолчанию веб-сервер ожидает подключение на 80-й порт. Эта договорённость справедлива для протокола HTTP. А для HTTPS-соединений действует другое правило: веб-серверы ожидают безопасные подключения по умолчанию на <code>443</code> порту.</p><p>Например, чтобы выполнить метод <code>HEAD /</code> для <code>https://htmlacademy.ru</code>, нам необходимо установить соединение с <code>443</code> портом вместо 80-го.</p><h2 id="rezyume">Резюме</h2><p>Спецификация протокола HTTP предусматривает множество заголовков и методов. Их не нужно заучивать прямо сейчас. На данном этапе важно понять общий принцип работы. С наиболее часто применяемыми методами и заголовками мы познакомимся при решении практических задач.</p><div class="post-content__wrapper"><div class="card card--rating card--rating-embedded" data-rating="" data-rating-comment=""><h3 class="card__header">Поделитесь, как вам глава?</h3><div class="card__content"><form action="/javascript/25/book/7.5/mark" class="card-rating" method="POST"><div class="card-rating__values"><input class="sr-only" id="book-rating-5" name="value" type="radio" value="5"/><label for="book-rating-5"><span class="sr-only">Глава — огонь!</span><svg aria-hidden="true" height="16" width="16"><use xlink:href="/img/sprites/octicons.v10.svg#star-fill-16"></use></svg></label><input class="sr-only" id="book-rating-4" name="value" type="radio" value="4"/><label for="book-rating-4"><span class="sr-only">Это было полезно</span><svg aria-hidden="true" height="16" width="16"><use xlink:href="/img/sprites/octicons.v10.svg#star-fill-16"></use></svg></label><input class="sr-only" id="book-rating-3" name="value" type="radio" value="3"/><label for="book-rating-3"><span class="sr-only">Неплохо, но можно лучше</span><svg aria-hidden="true" height="16" width="16"><use xlink:href="/img/sprites/octicons.v10.svg#star-fill-16"></use></svg></label><input class="sr-only" id="book-rating-2" name="value" type="radio" value="2"/><label for="book-rating-2"><span class="sr-only">Ничего полезного не было</span><svg aria-hidden="true" height="16" width="16"><use xlink:href="/img/sprites/octicons.v10.svg#star-fill-16"></use></svg></label><input class="sr-only" id="book-rating-1" name="value" type="radio" value="1"/><label for="book-rating-1"><span class="sr-only">Я напишу эту главу лучше</span><svg aria-hidden="true" height="16" width="16"><use xlink:href="/img/sprites/octicons.v10.svg#star-fill-16"></use></svg></label></div><p class="card-rating__title">Оцените главу</p><div class="card-rating__evaluate hidden"><span class="card-rating__text"></span></div><div class="card-rating__comment hidden"><label class="sr-only" for="book-rating-comment">Комментарий</label><div class="form__group"><textarea class="field field--area field--full-width" cols="40" id="book-rating-comment" name="comment" placeholder="Оставьте ваш комментарий." rows="2"></textarea><p class="form__notice form__notice--red hidden">Пожалуйста, оставьте комментарий.</p></div><button class="button button--small" type="submit">Отправить</button></div></form><p class="alert alert--green alert--full-width text-right hidden" data-rating-finish="" style="margin-top:10px;">Спасибо!</p></div></div><a class="button button--green" href="/javascript/25/book/7.5/complete">Продолжить</a></div></div><div class="card card--orphus"><div class="card__content"><p><svg aria-hidden="true" height="16" width="16"><use xlink:href="/img/sprites/octicons.v10.svg#shield-16"></use></svg> Если вы обнаружили ошибку или неработающую ссылку, выделите ее и нажмите Ctrl + Enter</p></div></div></div></div></div></div></div> <script id="" type="text/javascript">(function(a,e,f,g,b,c,d){a[b]=a[b]||function(){(a[b].a=a[b].a||[]).push(arguments)};a[b].l=1*new Date;c=e.createElement(f);d=e.getElementsByTagName(f)[0];c.async=1;c.src=g;d.parentNode.insertBefore(c,d)})(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym");ym(51609551,"init",{id:51609551,clickmap:!0,trackLinks:!0,accurateTrackBounce:!0,webvisor:!0});</script> <noscript><div><img alt="" src="https://mc.yandex.ru/watch/51609551" style="position:absolute; left:-9999px;"/></div></noscript> <div class="modal" data-item="0"><div class="modal__inner"><div class="modal__wrapper js-tutor-info hidden"><button class="modal__close icon-close" data-modal="close" title="Закрыть" type="button"></button><h3 class="modal__header text-left">Мой наставник</h3><p>Для полноценного прохождения курса вам нужно выбрать наставника.</p><p>После выбора вы сможете всегда держать под рукой его контакты (почту и ссылки на профиль в соцсетях, которые
      он укажет для связи со своими студентами), а также расписание консультаций.</p><p>Вы в любой момент можете поменять наставника, если вам кажется, что с текущим наладить работу не получается.</p></div><div class="modal__wrapper js-projects-info hidden"><button class="modal__close icon-close" data-modal="close" title="Закрыть" type="button"></button><h3 class="modal__header text-left">Мои проекты</h3><p>Для удобства работы с проектами, мы собрали их в этом блоке.</p><p>Основной личный проект, который вы будете готовить к финальной защите, находится в начале списка и рядом с ним
      стоит иконка <span class="up-icon"><svg aria-hidden="true" height="24" width="24"><use xlink:href="/img/sprites/octicons.v10.svg#heart-24"></use></svg></span>. Если на курсе
      используется учебный проект, то он будет следующим и с иконкой <span class="up-icon"><svg aria-hidden="true" height="24" width="24"><use xlink:href="/img/sprites/octicons.v10.svg#mortar-board-24"></use></svg></span>. Далее будут идти все остальные проекты, если
      для них были созданы репозитории.</p><p>Вы можете выбрать, какой именно проект будет основным, в любой момент прохождения курса, но мы советуем
      определиться с выбором как можно скорее.</p></div><div class="modal__wrapper js-tutor-task-value hidden"><button class="modal__close icon-close" data-modal="close" title="Закрыть" type="button"></button><h3 class="modal__header text-left">Оцените наставника</h3><p>Мы всегда стремимся улучшать качество услуг. И нам важно знать, как идёт ваша работа с наставником.</p><p>Уделите пару секунд вашего времени и дайте нам знать, как обстоят дела.</p><p>Также вы всегда можете задать свои вопросы напрямую <a href="/javascript/25/curator">куратору</a>.</p></div><div class="modal__wrapper js-first-todo hidden"><button class="modal__close icon-close" data-modal="close" title="Закрыть" type="button"></button><h3 class="modal__header text-left">Ваши первые задачи</h3><p>В этом списке мы собрали задачи, с которых начинается обучение на курсе.</p><p>Выполняйте задачи по порядку, а система будет автоматически отмечать галочками ваш прогресс. Когда весь список
      будет выполнен, этот блок закроется и больше не будет вам надоедать.</p></div><div class="modal__wrapper js-add-tutor-resource-request hidden modal--application-consultation"><button class="modal__close icon-close" data-modal="close" title="Закрыть" type="button"></button><h4 class="modal__header text-left">Запись на консультацию</h4><form action="/javascript/25/requests/create" class="consultation-form form" method="post" novalidate=""><div class="form__group radio-button-group"><label class="radio-button"><input checked="" class="radio-button__input" data-type="voice" name="consultation-type" type="radio" value="voice"/><span class="radio-button__text"><svg aria-hidden="true" height="16" width="16"><use xlink:href="/img/sprites/octicons.v10.svg#megaphone-16"></use></svg>
                  Голосовая</span></label><label class="radio-button"><input class="radio-button__input" data-type="text" name="consultation-type" type="radio" value="text"/><span class="radio-button__text"><svg aria-hidden="true" height="16" width="16"><use xlink:href="/img/sprites/octicons.v10.svg#pencil-16"></use></svg>
                  Текстовая</span></label><label class="radio-button"><input class="radio-button__input" data-type="review" name="consultation-type" type="radio" value="code-review"/><span class="radio-button__text"><svg aria-hidden="true" height="16" width="16"><use xlink:href="/img/sprites/octicons.v10.svg#code-review-16"></use></svg>
                  Кодревью</span></label></div><p class="form__text" data-type-content="voice"><b>Голосовая консультация</b> — это живое общение с наставником, который ответит на интересующие вас вопросы.</p><p class="form__text hidden" data-type-content="text"><b>Текстовая консультация</b> — это общение с наставником в чате. Чат доступен 1 день с момента начала консультации.</p><p class="form__text hidden" data-type-content="review"><b>Кодревью</b> — это проверка пулреквеста в репозитории вашего проекта. Наставник оставит комментарии к вашему коду.</p><div class="form__group" data-type-content="voice"><label class="form__label" for="voice-comment">Комментарий</label><div class="form__group-fields"><textarea class="field field--area field--full-width" cols="40" id="voice-comment" name="voice-comment" placeholder="Обсудить как строить сетки на гридах." rows="4"></textarea></div></div><div class="form__group hidden" data-type-content="text"><label class="form__label" for="text-comment">Список вопросов наставнику</label><div class="form__group-fields"><textarea class="field field--area field--full-width" cols="40" id="text-comment" name="text-comment" placeholder="Как строить сетки на гридах? Как правильно доступно скрыть блок?" rows="4"></textarea></div></div><div class="form__group hidden" data-type-content="review"><label class="form__label" for="pr_url">Ссылка на пулреквест</label><div class="form__group-fields"><input class="field field--text field--full-width" id="pr_url" name="pr_url" pattern="^https:\/\/github.com\/htmlacademy-javascript\/97687.+\/pull\/\d+" placeholder="https://github.com/htmlacademy-javascript/97687.../pull/.." required="" type="url" value=""/><p class="form__notice form__notice--red hidden"></p></div></div><div class="form__group hidden" data-type-content="review"><label class="form__label" for="code-review-comment">На что обратить внимание</label><div class="form__group-fields"><textarea class="field field--area field--full-width" cols="40" id="code-review-comment" name="code-review-comment" placeholder="Обратить внимание на строчку 20" rows="4"></textarea></div></div><button class="button button--full-width" type="submit">
        Записаться
    </button></form></div><div class="modal__wrapper js-orphus hidden" data-class-mod="modal--orphus"><button class="modal__close icon-close" data-modal="close" title="Закрыть" type="button"></button><h4 class="modal__header">Нашли опечатку?</h4><form action="/api/orphus" class="modal__form form"><input name="token" type="hidden" value="eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpbnRlbnNpdmUiOiIyMDkiLCJ1c2VyIjoiOTc2ODciLCJ1cmwiOiJodHRwczpcL1wvdXAuaHRtbGFjYWRlbXkucnVcL2phdmFzY3JpcHRcLzI1XC9ib29rXC83LjUifQ.kX5YtTqnXkRucnRSVPJEGQpuuh2jGGtNl5aNuVULjnY"/><div class="form__group"><div class="form__group-fields"><textarea class="field field--area field--full-width" cols="40" id="comment" name="comment" placeholder="Необязательно" rows="4"></textarea></div></div><button class="button button--full-width modal__button" type="submit">
        Отправить
    </button></form></div></div></div><script src="https://assets.htmlacademy.ru/js/up.v161.js"></script><script async="" data-assets="https://assets.htmlacademy.ru" data-require="toggle,tabs,tab-switcher,modal,ajax,autocomplete,orphus,newsfeed-messages,highlight,side-menu,github-embed,modal,form,tabs" src="https://assets.htmlacademy.ru/js/general.v223.js"></script><script async="" src="/static/js/scripts.13.js"></script><script src="https://assets.htmlacademy.ru/js/blog.v105.js"></script><script id="" type="text/javascript">(function(e,a){function f(b,a){b.prototype[a]=function(){this._q.push([a].concat(Array.prototype.slice.call(arguments,0)));return this}}function g(b){function a(a){b[a]=function(){b._q.push([a].concat(Array.prototype.slice.call(arguments,0)))}}for(var c=0;c<h.length;c++)a(h[c])}var c=e.amplitude||{_q:[],_iq:{}},b=a.createElement("script");b.type="text/javascript";b.integrity="sha384-d/yhnowERvm+7eCU79T/bYjOiMmq4F11ElWYLmt0ktvYEVgqLDazh4+gW9CKMpYW";b.crossOrigin="anonymous";b.async=!0;b.src="https://cdn.amplitude.com/libs/amplitude-5.2.2-min.gz.js";
b.onload=function(){e.amplitude.runQueuedFunctions||console.log("[Amplitude] Error: could not load SDK")};a=a.getElementsByTagName("script")[0];a.parentNode.insertBefore(b,a);b=function(){this._q=[];return this};a="add append clearAll prepend set setOnce unset".split(" ");for(var d=0;d<a.length;d++)f(b,a[d]);c.Identify=b;b=function(){this._q=[];return this};a=["setProductId","setQuantity","setPrice","setRevenueType","setEventProperties"];for(d=0;d<a.length;d++)f(b,a[d]);c.Revenue=b;var h="init logEvent logRevenue setUserId setUserProperties setOptOut setVersionName setDomain setDeviceId setGlobalUserProperties identify clearUserProperties setGroup logRevenueV2 regenerateDeviceId groupIdentify onInit logEventWithTimestamp logEventWithGroups setSessionId resetSessionId".split(" ");
g(c);c.getInstance=function(a){a=(a&&0!==a.length?a:"$default_instance").toLowerCase();c._iq.hasOwnProperty(a)||(c._iq[a]={_q:[]},g(c._iq[a]));return c._iq[a]};e.amplitude=c})(window,document);amplitude.getInstance().init("f602c01f1c06db4f52768e6adaa4eb56",google_tag_manager["GTM-W3ZS73J"].macro(4),{includeUtm:!0,includeGclid:!0,includeReferrer:!0,deviceIdFromUrlParam:!0},function(e){window.amplitudeLoaded=!0});</script><script id="" type="text/javascript">var eventProperties={};eventProperties.origin=google_tag_manager["GTM-W3ZS73J"].macro(5);eventProperties.domain=google_tag_manager["GTM-W3ZS73J"].macro(6);amplitude.getInstance().logEvent("user.visit",eventProperties);</script></body></html>